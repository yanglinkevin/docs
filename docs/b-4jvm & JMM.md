# 1.JMM
https://zhuanlan.zhihu.com/p/29881777  
https://zhuanlan.zhihu.com/p/136623445  
https://www.jianshu.com/p/8a58d8335270
![](figure/JMM.png)

Java内存模型(Java Memory Model，JMM)JMM主要是为了规定了线程和内存之间的一些关系。

jmm中的主内存、工作内存与jvm中的Java堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。

JMM即为JAVA 内存模型（java memory model）。因为在不同的硬件生产商和不同的操作系统下，内存的访问逻辑有一定的差异，结果就是当你的代码在某个系统环境下运行良好，并且线程安全，但是换了个系统就出现各种问题。

Java内存模型，就是为了屏蔽系统和硬件的差异，让一套代码在不同平台下能到达相同的访问结果。

# 2. volatile如何保证可见性以及防止指令重排序？
https://my.oschina.net/LucasZhu/blog/1537330
![](figure/zhilingchongpai.jpg)

上面的这段代码由于语句1和语句2没有数据依赖性，因此会发生指令重排。do2只要看到flag为true，就执行。因此可能的顺序是：

（1）语句1先于语句2：语句2->语句3->语句1->语句4。这时候的结果i=1。

（1）语句2先于语句1：语句2->语句3->语句4->语句1。这时候的结果i=0。

现在我们可以看到在多线程环境下如果发生了指令的重排序，会对结果造成影响。

volatile是如何保证有序性的？  
答：使用了内存屏障

1、什么是内存屏障

内存屏障其实就是一个CPU指令，在硬件层面上来说可以扥为两种：Load Barrier 和 Store Barrier即读屏障和写屏障。主要有两个作用：

（1）阻止屏障两侧的指令重排序；

（2）强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。

![](figure/neicunpingzhang1.jpg)

2、volatile如何保证可见性？

volatile主要保证可见性，可见性就是多个线程在同时修改一个变量时，A线程对变量的修改，B线程马上就能知道，有点像数据库里面脏读的那种感觉
底层实现：加入内存屏障，JVM的内存模型，线程有自己的工作内存，然后有主内存，被volatile修饰的变量被读取时，在读取前插入load指令，把主内存中的最新值拉到工作内存中，被写入时，在写入后插入store指令，把工作内存中的最新值刷新到主内存中

3、volatile如何保证有序性？

首先一个变量被volatile关键字修饰之后有两个作用：

（1）对于写操作：对变量更改完之后，要立刻写回到主存中。

（2）对于读操作：对变量读取的时候，要从主存中读，而不是缓存。

OK，现在针对上面JVM的四种内存屏障，应用到volatile身上。因此volatile也带有了这种效果。其实上面提到的这些内存屏障应用的效果，可以happen-before来总结归纳。

![](figure/happen-before.png)

3、内存屏障分类

内存屏障有三种类型和一种伪类型：

（1）lfence：即读屏障(Load Barrier)，在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主内存加载数据，以保证读取的是最新的数据。

（2）sfence：即写屏障(Store Barrier)，在写指令之后插入写屏障，能让写入缓存的最新数据写回到主内存，以保证写入的数据立刻对其他线程可见。

（3）mfence，即全能屏障，具备ifence和sfence的能力。

（4）Lock前缀：Lock不是一种内存屏障，但是它能完成类似全能型内存屏障的功能。

为什么说Lock是一种伪类型的内存屏障，是因为内存屏障具有happen-before的效果，而Lock在一定程度上保证了先后执行的顺序，因此也叫做伪类型。比如，IO操作的指令，当指令不执行时，就具有了mfence的功能。