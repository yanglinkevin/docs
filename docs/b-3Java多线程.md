# 1. 悲观锁，乐观锁，synchronized，volatile，CAS
- 悲观锁（Pessimistic Lock）： 
    - 每次获取数据的时候，都会担心数据被修改，所以每次获取数据的时候都会进行加锁，确保在自己使用的过程中数据不会被别人修改，使用完成后进行数据解锁。由于数据进行加锁，期间对该数据进行读写的其他线程都会进行等待。
   
    - 悲观锁比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。

- 乐观锁（Optimistic Lock）： 
    - 每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。
    
    - 比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。

- CAS
    - 所谓的CAS，一种乐观锁，即compareAndSwap，执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。  
            举个例子，内存值V、期望值A、更新值B，当V == A的时候将V更新为B。
    - CAS是原子操作
    - CAS是CPU的一个指令（需要JNI调用Native方法，才能调用CPU的指令）
    - CAS是非阻塞的、轻量级的乐观锁

- Synchronized
    - https://www.jianshu.com/p/d53bf830fa09  
    https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Multithread/synchronized.md
    - ![](figure/synchronized.png)
    
    - synchronized关键字最主要的三种使⽤⽅式
        - 修饰实例⽅法: 作⽤于当前对象实例加锁，进⼊同步代码前要获得当前对象实例的锁
            ```java
            public class SynchronizedDemo2 {
                public synchronized void method() {
                    System.out.println("synchronized ⽅法");
                }
            }
            ```
        - 修饰静态⽅法: 也就是给当前类加锁，会作⽤于类的所有对象实例，因为静态成员不属于任何⼀
        个实例对象，是类成员（static 表明这是该类的⼀个静态资源，不管new了多少个对象，只有
        ⼀份）。所以如果⼀个线程A调⽤⼀个实例对象的⾮静态 synchronized ⽅法，⽽线程B需要调⽤
        这个实例对象所属类的静态 synchronized ⽅法，是允许的，不会发⽣互斥现象， 因为访问静态
        synchronized ⽅法占⽤的锁是当前类的锁，⽽访问⾮静态 synchronized ⽅法占⽤的锁是当前
        实例对象锁。
        
        - 修饰代码块: 指定加锁对象，对给定对象加锁，进⼊同步代码库前要获得给定对象的锁。
            ```java 
            public class SynchronizedDemo {
                public void method() {
                    synchronized (this) {
                        System.out.println("synchronized 代码块");
                    }
                }
            }
            ```
    - synchronized底层实现：synchronized 关键字底层原理属于 JVM 层⾯
        
        - synchronized 同步语句块的情况  
        synchronized 同步语句块的实现使⽤的是 monitorenter 和 monitorexit 指令，其中 monitorenter
        指令指向同步代码块的开始位置， monitorexit 指令则指明同步代码块的结束位置。 当执⾏
        monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象
        头中， synchronized 锁便是通过这种⽅式获取锁的，也是为什么Java中任意对象可以作为锁的原因)
        的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执⾏
        monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞
        等待，直到锁被另外⼀个线程释放为⽌。
        
        - synchronized 修饰⽅法的的情况  
        同步方法通过加 ACC_SYNCHRONIZED 标识实现线程的执行权的控制
        
        - synchronized JDK1.6后的优化  
        Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。
        
        - synchronized优化后的锁  
        
            - ![](figure/synchronized1.png)
            
            - 锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。
            
            - 偏向锁：偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！但是对于锁竞争比较激烈的场合，偏向锁就失效了需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。
            
            - 当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程

            - 偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。
            
            - 轻量级锁：线程首先会通过cas获取锁，失败后通过自旋锁来尝试获取锁，再失败锁就膨胀为重量级锁。所以轻量级锁状态下可能会有自旋锁的参与（cas将对象头的标记指向锁记录指针失败的时候）
            
            - 线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁
                
            - 轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。

            - ![](figure/manylock.png)
            
            
# 2. volatile如何保证可见性以及防止指令重排序？
- 重排序场景
    - https://my.oschina.net/LucasZhu/blog/1537330
![](figure/zhilingchongpai.jpg)

    - 上面的这段代码由于语句1和语句2没有数据依赖性，因此会发生指令重排。do2只要看到flag为true，就执行。因此可能的顺序是：  
（1）语句1先于语句2：语句2->语句3->语句1->语句4。这时候的结果i=1。  
（2）语句2先于语句1：语句2->语句3->语句4->语句1。这时候的结果i=0。

    - 现在我们可以看到在多线程环境下如果发生了指令的重排序，会对结果造成影响。

- volatile是如何保证有序性的？  答：使用了内存屏障
    - 什么是内存屏障  
    内存屏障其实就是一个CPU指令，在硬件层面上来说可以扥为两种：Load Barrier 和 Store Barrier即读屏障和写屏障。主要有两个作用：  
    （1）阻止屏障两侧的指令重排序；  
    （2）强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。  
    ![](figure/neicunpingzhang1.jpg)

- volatile如何保证可见性？
    - volatile主要保证可见性，可见性就是多个线程在同时修改一个变量时，A线程对变量的修改，B线程马上就能知道，有点像数据库里面脏读的那种感觉
底层实现：加入内存屏障，JVM的内存模型，线程有自己的工作内存，然后有主内存，被volatile修饰的变量被读取时，在读取前插入load指令，把主内存中的最新值拉到工作内存中，被写入时，在写入后插入store指令，把工作内存中的最新值刷新到主内存中

- volatile如何保证有序性？
    - 首先一个变量被volatile关键字修饰之后有两个作用：  
    对于写操作：对变量更改完之后，要立刻写回到主存中。  
    对于读操作：对变量读取的时候，要从主存中读，而不是缓存。
    
    - OK，现在针对上面JVM的四种内存屏障，应用到volatile身上。因此volatile也带有了这种效果。其实上面提到的这些内存屏障应用的效果，可以happen-before来总结归纳。
    - ![](figure/happen-before.png)

- 内存屏障分类
    - 内存屏障有三种类型和一种伪类型：
    - lfence：即读屏障(Load Barrier)，在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主内存加载数据，以保证读取的是最新的数据。
    - sfence：即写屏障(Store Barrier)，在写指令之后插入写屏障，能让写入缓存的最新数据写回到主内存，以保证写入的数据立刻对其他线程可见。
    - mfence，即全能屏障，具备ifence和sfence的能力。
    - Lock前缀：Lock不是一种内存屏障，但是它能完成类似全能型内存屏障的功能。
    
    - 为什么说Lock是一种伪类型的内存屏障，是因为内存屏障具有happen-before的效果，而Lock在一定程度上保证了先后执行的顺序，因此也叫做伪类型。比如，IO操作的指令，当指令不执行时，就具有了mfence的功能。