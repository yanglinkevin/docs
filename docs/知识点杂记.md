- 线程数设置和CPU数的关系?
    - 如果是CPU密集型应用，则线程池大小设置为N+1

    - 如果是IO密集型应用，则线程池大小设置为2N+1（因为io读数据或者缓存的时候，线程等待，此时如果多开线程，能有效提高cpu利用率）

    - 线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。

- 协程可以利用多核吗？
    - 1.协程的切换开销更小，属于程序级别的切换，操作系统完全感知不到，因而更加轻量级 　
    - 2.单线程内就可以实现并发的效果，最大限度地利用cpu
　  
    - 1.协程的本质是单线程下，无法利用多核，可以是一个程序开启多个进程，每个进程内开启多个线程，每个线程内开启协程
　　
- 为什么内存比磁盘块？
    - 存储原理完全不同，内存（随机存储器）依靠电脉冲 配合CPU的直接寻址寄存器 机械硬盘需要机械指针寻找需要的盘面和扇区

- 计算密集型？
    - 计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。

- io密集型？
    - IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。

- 多进程和多线程的应用场景?
- ![](figure/xianchengjinchengduibi.png)
    - 1）需要频繁创建销毁的优先用线程
    - 2）需要进行大量计算的优先使用线程
        - 大量计算，当然就是要耗费很多CPU，切换频繁了，这种情况下线程是最合适的。
    - 3）强相关用线程，弱相关用进程
    - 4) 不同任务间需要大量共享数据或频繁通信时用线程
- CPU密集型任务适合多进程还是多线程？
    - 线程

- 为什么1G文件传输比1000个1M文件传输的块？
    - ===============如果“传输”指网络传输===============无论采用FTP协议、HTTP协议或是软件自定义协议传输文件,都是基于TCP,TCP协议可以用一条……咳咳,两条水管来比喻,其中一条水管一面只管灌水,一面接收水。水的流量可以很大,但水在管里流动有一定的速度,所以水从一边传到另一边有时间差。而传送大量小文件时的情况就比较复杂,要看传输文件的协议是怎么规定的,对于常见的FTP和HTTP传送大量文件时都很低效,这就像用水管每次只传一杯水,接水的一方确认收到后,再给出指令传送下一杯水,刚才说了水传输是有延时的,于是大部分时间都浪费在这种延时上,水管的流量没被充分利用。要解决这样的问题很简单,将大量文件打包成一个文件一起发送,这也是下载服务常规做法,你下载的软件安装包都是一个文件,双击运行后才解包成多个文件。===============如果“传输”指一台机内拷贝、读写文件==============机械硬盘对盘面一段连续区间的读写速度非常高,但如果在一个地方读写完后又换去别的地方读写就会造成寻道:磁头移动到下一个读写位置。系统读写单个文件一般都可以连续读写,而访问大量文件就需要频繁寻道,因为不同文件在硬盘上一般不会放在一起的。单次寻道的时间很短,大约是10毫秒级别,人一般不会察觉,但如果太频繁了就非常明显。例如一个1G大小的文件,现代硬盘可以在20秒内完成访问,但如果将1G分成10万个10k的文件,那就造成至少10万次寻道,每次寻道10毫秒,那就消耗了1000秒时间来寻道。实际应用中还复杂得多,寻道次数可能是2倍以上。即使固态硬盘没有寻道过程,对大量文件的访问仍然有一定的性能影响。例如对1G的文件读入内存,只需要简单一组CPU指令就可以让硬盘连续工作并把数据直接写入内存,而如果访问大量文件,操作系统发送一条传送指令后等待硬盘完成,再根据结果又执行下一条指令,大部分时间都浪费在指令延时上。如果用网络传输的文件非常多,或者网络的速度非常快,寻道延时造成的影响也会很显著。
    
- 介绍下操作系统内存管理
    - 操作系统内存管理几个方面
        - 内存的创建与回收
        - 逻辑地址寻址到物理地址
        - 扩充物理内存
        - 每个进程有独立的地址空间
    
    - 一般都用虚拟内存来进行操作系统内存管理
        - 虚拟内存是会给每个进程分配独立内存空间，当然实际上是离散的，有些在物理内存中，有些在磁盘中，有些甚至还没有分配。
        - 当程序逻辑地址去找物理地址的时候，会去页表中去找，页表里有三种状态存在，已分配物理内存，不在物理内存中（在磁盘中），还未分配。
        - 如果逻辑地址对应的状态是已分配物理内存，就可以直接寻址到那块物理地址。如果在磁盘上，则需要触发缺页中断，将物理内存中的一些页删掉，
        将磁盘上的内容加载进内存中。

- ping协议是什么？ icmp属于哪一层的协议？
    - Linux ping命令用于检测主机。
    - 执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。
    
    - icmp是网络层协议
    - ping本身在应用层，使用icmp协议，和传输层没有关系。
    
- 内存分配算法？
    - 最佳适应算法（Best Fit)：从全部空闲区中找出能满足作业要求的、且大小最小的空闲分区，这种方法能使碎片尽量小。

- id是auto_increment的，多个事务同时插入数据，为什么能保证id不被重复分配呢？
    主键索引创建的时候已经是唯一性索引了
    

- 单机限流，分布式限流？？？

- synchronized和lock区别，lock的过程，在没获取到锁的时候是什么状态？？

- rand5生成rand7
    - num=5*（rand5-1）+rand5-1

    if(num<21)
    
    print num%7+1;
    
    其中5*（rand5-1）生成等概率的数0,5,10,15,20，而后面的rand5-1生成等概率的0,1,2,3,4
    
    这样两个数相加，就可以得到等概率的0-24.
    
    这个时候取0-20就可以等概率的区分，rand7的每个数字在这其中出现了3次，概率相等。

- https://www.cnblogs.com/cangqinglang/p/13201388.html 很全的输入url后怎么到服务端的

- websocket
    - 其实就是主动推送啦  比如有个主播开播了，就可以用websocket主动推送给订阅的客户呀。
    它也是一种协议
    http中请记住 Request = Response ， 在HTTP中永远是这样，也就是说一个request只能有一个response。而且这个response也是被动的，不能主动发起。
    而websocket是可以主动去发起消息的。
    ajax轮询 的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。
    long poll 其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。
    
    - http long poll，或者ajax轮询不都可以实现实时信息传递么。
    ajax轮询 需要服务器有很快的处理速度和资源。（速度）
    long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小）
    Websocket只需要一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议，还要查看identity info的信息。
    同时由客户主动询问，转换为服务器（推送）有信息的时候就发送（当然客户端还是等主动发送信息过来的。。），没有信息的时候就交给接线员（Nginx），不需要占用本身速度就慢的客服（Handler）了
    https://www.zhihu.com/question/20215561
    
- nginx
    - ![](figure/nginx1.png)
    
    - ![](figure/nginx2.png)
    
    - ![](figure/nginx3.png)
    
- xss攻击和sql攻击

    - ![](figure/xsssql.png)
    
- 为什么线程切换会导致用户态和内核态的切换？
    - 因为线程的调度是在内核态运行的，而线程中的代码是在用户态运行

